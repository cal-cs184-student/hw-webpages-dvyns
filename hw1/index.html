<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp26">cs184.eecs.berkeley.edu/sp26</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp26">cs184.eecs.berkeley.edu/sp26</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		
		In <code class="language-plaintext highlighter-rouge">src/rasterizer.cpp</code>, we rasterize each triangle by first computing the smallest axis-aligned bounding box that contains all three vertices of a given triangle. 
		Then we clamp that box to the framebuffer and iterate through each sample point inside that box. 
		For each sample, we evaluate the three edge functions (signed cross products against the triangle's directed edges). 
		If the sample has a consistent sign for all three edge tests, it is inside or on the boundary of the triangle, so we fill that sample with the triangle color; otherwise we skip it. 
		
		<p>This is no worse than checking each sample in the bounding box because that is exactly what we are doing.</p>

		<p>Screenshots below. The effect of supersampling is most visible on the center and bottom right triangles.</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="size1_new.png" width="500px"/>
				  <figcaption>Supersample rate 1 per pixel.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="size4_new.png" width="500px"/>
				  <figcaption>Supersample rate 4 per pixel.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="size9_new.png" width="500px"/>
				  <figcaption>Supersample rate 9 per pixel.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="size16_new.png" width="500px"/>
				  <figcaption>Supersample rate 16 per pixel.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
			
				<b>Algorithm and Data Structures </b>
 <p>The supersample buffer is sample_buffer, a std::vector<Color> resized to width * height * sample_rate. Each pixel (x, y) owns a contiguous block of sample_rate entries, indexed as: sample_buffer[(y * width + x) * sample_rate + (j * sq_sample + i)]
	where i, j ∈ [0, sq_sample] and sq_sample = sqrt(sample_rate).</p>
			<p>Pipeline modifications:
set_sample_rate() / set_framebuffer_target() — both resize sample_buffer to width * height * sample_rate, ensuring the buffer always matches the current window size and sampling rate.
clear_buffers() — fills both rgb_framebuffer_target and sample_buffer with white before each frame.
rasterize_triangle() — for each pixel in the bounding box, iterates over a sq_sample × sq_sample grid of sub-sample locations. Each sub-sample offset is placed at the center of its sub-pixel cell: float dx = (2.0f * i + 1) / (2.0f * sq_sample);
float dy = (2.0f * j + 1) / (2.0f * sq_sample);</p>

<p> Sub-samples passing the three edge tests are written into the sample_buffer. The winding-agnostic check (all ≥ 0) || (all ≤ 0) handles both CW and CCW triangles.
	fill_pixel() — used by points and lines. Writes the same color to all sample_rate slots for the pixel, so averaging during resolve produces the correct solid color with no supersampling effect.
	resolve_to_framebuffer() it averages all sample_rate Color entries for each pixel, multiplies by 1/sample_rate, then writes clamped 8-bit RGB values into rgb_framebuffer_target.
</p>
<b> Why Supersampling Is Useful</b>
<p>
	
	Supersampling is a valuable technique for reducing aliasing. Sampling multiple locations within each pixel and averaging the results creates smoother edges and more accurately represents pixels that are only partially covered by an object.

</p>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
	  <tr>
		<td style="text-align: center;">
		  <img src="size1_new.png" width="500px"/>
		  <figcaption>Supersample rate 1 per pixel.</figcaption>
		</td>
		<td style="text-align: center;">
		  <img src="size4_new.png" width="500px"/>
		  <figcaption>Supersample rate 4 per pixel.</figcaption>
		</td>
	  </tr>
	  <tr>
		
		<td style="text-align: center;">
		  <img src="size16_new.png" width="500px"/>
		  <figcaption>Supersample rate 16 per pixel.</figcaption>
		</td>
	  </tr>
	</table>
</div>

<h1>Explained result of the imagees</h1>
<p>
	<p>	At sample rate 1, the skinny triangle corner shows dramatic aliasing the entire pixels are skipped because the single center sample misses the very narrow geometry, producing disconnected or missing pixels and harsh jagged edges.
	</p>
	<p>At sample rate 4, the corner becomes noticeably smoother. Pixels that are only partially covered by the triangle receive a blended color (roughly 1/4, 2/4, or 3/4 intensity depending on how many of the 4 sub-samples fall inside), creating a soft gradient along the edge. The thin tip is now visibly continuous.
	</p>
	<p>At sample rate 16, the effect is even more pronounced. With 16 sub-samples, the coverage fraction for each edge pixel is estimated much more finely and smoother (in increments of 1/16 rather than 1/4), producing a smoother gradient and better preserving the thin tip geometry. The triangle corner appears nearly continuous and the staircase artifact is largely eliminated.
	</p>
</p>




			</p>
		<h2>Task 3: Transforms</h2>
			<p>
				I posed cubeman in a mid-stride running position. I rotated the torso slightly forward to simulate motion and rotated the legs in opposite directions to create a dynamic stride. The arms swing opposite to the legs to mimic natural running biomechanics.
				I also adjusted limb proportions and used different colors to better visualize the hierarchical transforms and make the pose more expressive.
			</p>
			<figure>
				<img src="screenshot_2-19_11-57-10.png" alt="dancing img" style="width: 80%"/>
			</figure>

		
		<h2>Task 4: Barycentric coordinates</h2>
		<p></p>Suppose you have a triangle with vertices \(A\equiv (x_A, y_A)\), \(B\equiv (x_B, y_B)\), and \(C\equiv (x_C, y_C)\) 
		and for some point inside the triangle \(P\equiv (x_P, y_P)\), the barycentric coordinates of \(P\) are \((\alpha, \beta, \gamma)\).
		Then \(\alpha\) is the proprtion of the area of the triangle \(ABC\) that is covered by the triangle \(PBC\), and similarly 
		for \(\beta\) and \(\gamma\). Triangle \(PBC\) is necessarily inside triangle \(ABC\) by defintion. The triangles \(PBC\), \(APC\), and \(ABP\) 
		clearly sum together to make up all of \(ABC\) as shown to below.</p>
		
		<p>Screenshot from <code>svg/basic/test7.svg</code> is shown also below:</p>
		<div style="clear: both"></div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="triangle.png" width="300px"/>
				  <figcaption></figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test7.png" width="400px"/>
				  <figcaption>Test 7 screenshot.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
			<p>
				Pixel sampling is the process of determining what color a pixel on screen should be by looking up a corresponding point in a texture image.
				When we rasterize a textured triangle, each vertex has both a screen-space position \((x, y)\) and a texture-space coordinate \((u, v)\) in the range [0, 1]. 
				For any pixel inside the triangle, we compute its barycentric coordinates \(\alpha, \beta, \gamma\) and use them to interpolate the texture coordinates: \(v=\alpha v_A + \beta v_B + \gamma v_C\), and similarly for \(u\). 
				We then scale \(u\) and \(v\) by the texture's width and height to get a continuous texel coordinate, and sample a color from the texture at that location.
			</p>
			<p>
				Nearest neighbor sampling rounds the continuous texel coordinate to the nearest integer texel and returns that texel's color. It's fast but can look blocky or aliased, especially when zoomed in, because it doesn't consider surrounding texel information.

			</p>
			<p>
				Bilinear sampling takes the four texels surrounding the continuous sample point and blends them using linear interpolation, first horizontally between the two left and two right texels, then vertically between the resulting two colors. This produces a much smoother result because the sampled color is a weighted average of its neighbors based on how close the sample point is to each.
			</p>

			<h2>nearest sampling </h2>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-30-58.png" alt="nearest sampling img" width="500px">
				  <figcaption>Nearest Sampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-31-21.png" alt="bilinear sampling img" width="500px">
				  <figcaption>Bilinear Sampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-31-30.png" alt="nearest sampling" width="500px">
				  <figcaption>Nearest Sampling + 16 per pixel supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-31-8.png" alt="supersample 16 img" width="500px">
				  <figcaption>Bilinear Sampling + 16 per pixel supersampling.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

				<p>
					The relative difference between nearest neighbor and bilinear sampling in the picture above is that the dotted line in the picture seems a bit blurrier in the bilinear sampling  while the nearest sampling looks sharp, clear and blocky.
				</p>
				<p>
					When there will be a big difference between nearest neighbor and bilinear sampling is when the texture is viewed at a steep angle or from a distance, causing it to be minified. In these cases, nearest neighbor can produce severe aliasing artifacts, while bilinear sampling will still provide a smoother appearance by blending texels together.
				</p>
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling is an antialising technique that samples from downsampled versions of our texture stored in a mipmap at various
		 mipmap levels. It chooses a level based on how fast a change in pic

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lzero_pnear.png" width="500px"/>
				  <figcaption>L_ZERO and P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lzero_plin.png" width="500px"/>
				  <figcaption>L_ZERO and P_LINEAR.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lnear_pnear.png" width="500px"/>
				  <figcaption>L_NEAR and P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lnear_plin.png" width="500px"/>
				  <figcaption>L_NEAR and P_LINEAR.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
