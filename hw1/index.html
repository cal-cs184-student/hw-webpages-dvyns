<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Tunmise Akanle, David Smith</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-dvyns/hw1/index.html">https://cal-cs184-student.github.io/hw-webpages-dvyns/hw1/index.html</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-any-name-works#">https://github.com/cal-cs184-student/hw1-rasterizer-any-name-works#/sp26</a>


		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p>We modified a 2D rasterization pipeline that converts SVG geometry into screen pixels to implement triangle rasterization and geometric transforms. 
			We started with a point-in-triangle tests over a bounding box for each triangle then we layered on supersampling for antialiasing,
			 barycentric coordinates for color interpolation, and additional pixel sampling and level sampling methods to implement texture mapping.</p>
		
		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<figure>
			<img src="task1.png" alt="Lion" style="float: right" width="40%"/>
		</figure>
		In <code class="language-plaintext highlighter-rouge">src/rasterizer.cpp</code>, we rasterize each triangle by first computing the smallest axis-aligned bounding box that contains all three vertices of a given triangle. 
		Then we clamp that box to the framebuffer and iterate through each sample point inside that box. 
		For each sample, we evaluate the three edge functions (signed cross products against the triangle's directed edges). 
		If the sample has a consistent sign for all three edge tests, it is inside or on the boundary of the triangle, so we fill that sample with the triangle color; otherwise we skip it. 
		
		<p>This is no worse than checking each sample in the bounding box because that is exactly what we are doing.</p>

		<p> We were unsure what qualified as an interesting part of the image so we just centered it. Centering the image gives
			a good view of how our current method of rasterization effects aliasing with the different shapes of triangles.
		</p>
		
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
			
		<p>The supersample buffer is sample_buffer, a <code >std::vector<Color></code> resized to <code>width * height * sample_rate</code>. Each pixel \((x, y)\) owns a contiguous block of <code>sample_rate</code> entries, indexed as: 
			<p style="text-align: center;"><code>
			sample_buffer[(y * width + x) * sample_rate + (j * sq_sample + i)]
		  </code></p>
		  <p>
			where <code>i, j ∈ [0, sq_sample]</code> and 
			<code>sq_sample = sqrt(sample_rate)</code>.
		  </p>		</p>
		<p>Pipeline modifications:
			<p style="padding-left: 30px">
				<code>set_sample_rate()</code> / <code>set_framebuffer_target()</code> — both resize sample_buffer to width * height * sample_rate, ensuring the buffer always matches the current window size and sampling rate.
			</p>
			<p style="padding-left: 30px">
				<code>clear_buffers()</code>: fills both rgb_framebuffer_target and sample_buffer with white before each frame.
			</p>
			
			<p style="padding-left: 30px">
				<code>rasterize_triangle()</code>: for each pixel in the bounding box, iterates over a sq_sample × sq_sample grid of sub-sample locations. Each sub-sample offset is placed at the center of its sub-pixel cell: 
			<p style="text-align: center;">
				<code>
				  float dx = (2.0f * i + 1) / (2.0f * sq_sample); <br>
				  float dy = (2.0f * j + 1) / (2.0f * sq_sample);
				</code>
		</p>

	<p style="padding-left: 30px"> 
		Sub-samples passing the three edge tests are written into the sample_buffer. We use a winding-agnostic check (all ≥ 0) || (all ≤ 0) that handles both CW and CCW triangles.
	</p>
	<p style="padding-left: 30px;">
		<code>fill_pixel()</code> — used by points and lines. Writes the same color to all sample_rate slots for the pixel, so averaging during resolve produces the correct solid color with no supersampling effect.
	</p>
	<p style="padding-left: 30px;">
	<code>resolve_to_framebuffer()</code> it averages all sample_rate Color entries for each pixel, multiplies by 1/sample_rate, then writes clamped 8-bit RGB values into rgb_framebuffer_target.
</p>
<h3> Why Supersampling Is Useful</h3>
<p>
	
	Sampling multiple locations within each pixel and averaging the results creates smoother edges and more accurately represents pixels that are only partially covered by an object.

</p>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
	  <tr>
		<td style="text-align: center;">
		  <img src="size1_new.png" width="100%"/>
		  <figcaption>Supersample rate 1 per pixel.</figcaption>
		</td>
		<td style="text-align: center;">
		  <img src="size4_new.png" width="100%"/>
		  <figcaption>Supersample rate 4 per pixel.</figcaption>
		</td>
		<td style="text-align: center;">
		  <img src="size16_new.png" width="100%"/>
		  <figcaption>Supersample rate 16 per pixel.</figcaption>
		</td>
	  </tr>
	  <tr>
		
		
	  </tr>
	</table>
</div>

		<h3>Results from the images:</h3>
		<p>
			<p>	At sample rate 1, the skinny triangle corner shows dramatic aliasing the entire pixels are skipped because the single center sample misses the very narrow geometry, producing disconnected or missing pixels and harsh jagged edges.
			</p>
			<p>At sample rate 4, the corner becomes noticeably smoother. Pixels that are only partially covered by the triangle receive a blended color (roughly 1/4, 2/4, or 3/4 intensity depending on how many of the 4 sub-samples fall inside), creating a soft gradient along the edge. The thin tip is now visibly continuous.
			</p>
			<p>At sample rate 16, the effect is even more pronounced. With 16 sub-samples, the coverage fraction for each edge pixel is estimated much more finely and smoother (in increments of 1/16 rather than 1/4), producing a smoother gradient and better preserving the thin tip geometry. The triangle corner appears nearly continuous and the staircase artifact is largely eliminated.
			</p>
		</p>




			</p>
		<h2>Task 3: Transforms</h2>
			<p>
				We posed cubeman in a mid-stride running position. We rotated the torso slightly forward to simulate motion and rotated the legs in opposite directions to create a dynamic stride. The arms swing opposite to the legs to mimic natural running biomechanics.
				We also adjusted limb proportions and used different colors to better visualize the hierarchical transforms and make the pose more expressive.
			</p>
			<figure>
				<img src="screenshot_2-19_11-57-10.png" alt="dancing img" style="width: 80%"/>
			</figure>

		
		<h2>Task 4: Barycentric coordinates</h2>
		<p>Suppose you have a triangle with vertices \[A\equiv (x_A, y_A), B\equiv (x_B, y_B),\text{ and }C\equiv (x_C, y_C)\] 
		and some point inside the triangle \(P\equiv (x_P, y_P)\). The barycentric coordinates of \(P\) are \((\alpha, \beta, \gamma)\).
		Then \(\alpha\) is the proprtion of the area of the triangle \(ABC\) that is covered by the triangle \(PBC\), and similarly 
		for \(\beta\) and \(\gamma\). Triangle \(PBC\) is necessarily inside triangle \(ABC\) by defintion. The triangles \(PBC\), \(APC\), and \(ABP\) 
		clearly sum together to make up all of \(ABC\) since the lines from each vertice to \(P\) trisect \(ABC\). This is shown below.</p>
		
		<p>Screenshot from <code>svg/basic/test7.svg</code> is shown also below:</p>
		<div style="clear: both"></div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="triangle.png" width="75%"/>
				  <figcaption></figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test7.png" width="100%"/>
				  <figcaption>Test 7 screenshot.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		<p>
			<strong>Pixel sampling</strong> is the process of determining the color of a pixel on the screen by looking up the corresponding point in a texture image.
		  </p>
		  
		  <p>
			When rasterizing a textured triangle, each vertex has both a screen-space position 
			<span>(x, y)</span> and a texture-space coordinate 
			<span>(u, v)</span> in the range <span>[0, 1]</span>.
		  </p>
		  
		  <p>
			For any pixel inside the triangle, we compute its barycentric coordinates 
			<span>&alpha;, &beta;, &gamma;</span> and use them to interpolate the texture coordinates:
		  </p>
		  
		  <p style="text-align: center;">
			<em>
			  v = &alpha;v<sub>A</sub> + &beta;v<sub>B</sub> + &gamma;v<sub>C</sub><br>
			  u = &alpha;u<sub>A</sub> + &beta;u<sub>B</sub> + &gamma;u<sub>C</sub>
			</em>
		  </p>
		  
		  <p>
			We then scale <span>u</span> and <span>v</span> by the texture’s width and height to obtain a
			continuous texel coordinate, and sample the color from the texture at that location.
		  </p>
			<p>
				Nearest neighbor sampling rounds the continuous texel coordinate to the nearest integer texel and returns that texel's color. It's fast but can look blocky or aliased, especially when zoomed in, because it doesn't consider surrounding texel information.

			</p>
			<p>
				Bilinear sampling takes the four texels surrounding the continuous sample point and blends them using linear interpolation, first horizontally between the two left and two right texels, then vertically between the resulting two colors. This produces a much smoother result because the sampled color is a weighted average of its neighbors based on how close the sample point is to each.
			</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-30-58.png" alt="nearest sampling img" width="100%">
				  <figcaption>Nearest Sampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-31-21.png" alt="bilinear sampling img" width="100%">
				  <figcaption>Bilinear Sampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-31-30.png" alt="nearest sampling" width="100%">
				  <figcaption>Nearest Sampling + 16 per pixel supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-20_22-31-8.png" alt="supersample 16 img" width="100%">
				  <figcaption>Bilinear Sampling + 16 per pixel supersampling.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

				<p>
					The relative difference between nearest neighbor and bilinear sampling in the picture above is that the dotted line in the picture seems a bit blurrier in the bilinear sampling  while the nearest sampling looks sharp, clear and blocky.
				</p>
				<p>
					When there will be a big difference between nearest neighbor and bilinear sampling is when the texture is viewed at a steep angle or from a distance, causing it to be minified. In these cases, nearest neighbor can produce severe aliasing artifacts, while bilinear sampling will still provide a smoother appearance by blending texels together.
				</p>
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		 <p> Level sampling is an antialising technique that samples from downsampled versions of our texture stored in a mipmap at various
		 mipmap levels. It chooses a level based on how fast the texture space position changes relative to changes in pixel space position.
		 When this rate of change is high (e.g. <code>dudx</code> and <code>dudy</code> in <code>Texture::get_level</code> are large), 
		 it samples from a lower resolution mipmap. This avoids aliasing artifacts that would occur if we sampled from a higher resolution 
		 image since we would be well below its's nyquist frequency.
		</p>

		 <p>
			We implemented this in the <code>Texture::get_level</code>, <code>Texture::sample</code>, and <code>RasterizerImp::rasterize_textured_triangle</code> functions.
		 </p>
		 <p>
			<code>RasterizerImp::rasterize_textured_triangle</code> implements the same basic supersampling algorithm used in Task 2 except,
			for each sample point, we create and assign a <code>SampleParams</code> struct <code>sp</code> with barycentric 
			interpolated positions in \(u,v\)-space for the sample positions <code>\((x,y),(x+1,y)\) </code>and </code>\((x,y+1)\)</code>. 
			The <code>sp</code> instance is also assigned a pixel method variable and a level method variable, then passed into
			<code>Texture::sample</code>.
		 </p>
		 <p>
			<code>Texture::sample</code> uses the pixel and level methods of <code>SampleParams</code> to determine how to sample the texture,
			then provides function calls to the <code>Texture::sample_nearest</code> and <code>Texture::sample_bilinear</code> functions implemented in Task 5
			at levels provided by a call to <code>Texture::get_level</code>.
		 </p>
		 <p>
			<code>Texture::get_level</code> returns the appropriate mipmap level for a given <code>SampleParams</code> instance. 
			It takes the base two logarithm of the max of the magnitude of the vectors 
			\[\left(\frac{du}{dx}\mathbf{\hat{u}}+\frac{dv}{dx}\mathbf{\hat{v}}\right)\text{ and }
			\left(\frac{du}{dy}\mathbf{\hat{u}}+\frac{dv}{dy}\mathbf{\hat{v}}\right).\] 
		 </p>
		 <p>
			For pixel sampling:
			<p style="padding-left: 30px">
				Nearest sampling is computationally the cheapest by far, but it has pretty terrible quality for most images. It does nothing to reduce aliasing.
			</p>
			<p style="padding-left: 30px">
				Bilinear sampling reduces aliasing by doing linear interpolation three times: twice in the \(u\)-direction, then once in the \(v\)-direction.
				This usually provides a better estimate of what the color value would be at a point, but it is more expensive and can lead to blurring.
			</p>
		 </p>
		 <p>
			For level sampling:
			<p style="padding-left: 30px">
				Using the first mipmap level (<code>L_ZERO</code>) is the equivalent of not using any mipmap at all, which saves a bit on memory. It is the fastest 
				of the level sampling methods but it can cause aliasing when sampled textures are far away or at weird angles.
			</p>
			<p style="padding-left: 30px">
				Using the nearest mipmap level (<code>L_NEAR</code>) is more expensive than <code>L_ZERO</code> but cheaper than <code>L_LINEAR</code>.
				It helps to avoid aliasing but it can lead to "jumps" in texture appearance when switching between mipmap levels.
			</p>
			<p style="padding-left: 30px">
				Using the linear mipmap level (<code>L_LINEAR</code>) basically performs nearest mipmap sampling at the two closest mipmap levels then interpolates between them.
				This reduces some of the jumpiness of the nearest mipmap sampling method, but add some additional overhead with the interpolation.
			</p>

			<p>
				Supersampling, if done at a high enough rate is the most effective way to deal with aliasing. However, it dwarfs the other methods in memory
				and computational costs. It requires you to store some multiplicative factor of samples for every pixel, then runs whatever pixel/level sampling method you are using
				on every single sample. The sampling rate required to fully remove/deal with aliasing can be so high that it becomes impractical for some tasks.
			</p>
		 </p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lzero_pnear.png" width="100%"/>
				  <figcaption>L_ZERO and P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lzero_plin.png" width="100%"/>
				  <figcaption>L_ZERO and P_LINEAR.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lnear_pnear.png" width="100%"/>
				  <figcaption>L_NEAR and P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lnear_plin.png" width="100%"/>
				  <figcaption>L_NEAR and P_LINEAR.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		
		</div>
	</body>
</html>
